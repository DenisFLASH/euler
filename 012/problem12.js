// Highly divisible triangular number

/*
The sequence of triangle numbers is generated by adding the natural numbers. So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The first ten terms would be:

1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...

Let us list the factors of the first seven triangle numbers:

 1: 1
 3: 1,3
 6: 1,2,3,6
10: 1,2,5,10
15: 1,3,5,15
21: 1,3,7,21
28: 1,2,4,7,14,28
We can see that 28 is the first triangle number to have over five divisors.

What is the value of the first triangle number to have over five hundred divisors?
*/
function solveProblem12() {
  var MAX_DIVISORS = 500;
  var start = new Date().getTime();
  var result = findHighlyDivisibleTriangularNumber(MAX_DIVISORS);
  var time = new Date().getTime() - start;
  document.getElementById("answer").innerHTML = 'First triangle number to have over ' + MAX_DIVISORS + ' divisors: ' + result + '<br> execution time: ' + time + ' ms<br>';
}

function findHighlyDivisibleTriangularNumber(maxDivisors) {
  var currentNumber = 0,
      delta = 1,
      divisors = 0,
      isFound = false,
      squareRoot;

/*
  // To output 5 intermediate results
  var intermediateDivisors = [],
      foundIntermediate = [];
  var steps = 5;
  for (var i = 0; i < steps; i++) {
    intermediateDivisors.push(maxDivisors/steps * (i+1));
    foundIntermediate.push(false);
  }
  console.log(intermediateDivisors);
  console.log(foundIntermediate);*/


  while (!isFound) {
    currentNumber += delta;
    delta++;
    divisors = 0,
    squareRoot = Math.sqrt(currentNumber);

    // 28: 1,2,4,7,14,28  ==> 1*28 = 2*14 = 4*7  ==> we can loop till Sqrt(number), and then double the number of divisors.
    for (var i = 1; i < squareRoot; i++) {
      if (currentNumber % i == 0) {
        divisors++;
      }
    }
    divisors *= 2;
    // One special case which is not mirror (divisors of 36 has 9 divisors: 1, 2, 3, 4, 6, 9, 12, 18, 36)
    if (squareRoot*squareRoot == currentNumber) {
      divisors++;
    }

    /*for (var i = 0; i < steps; i++) {
      if (!foundIntermediate[i]) {
        if (divisors > intermediateDivisors[i]) {
          console.log(currentNumber + ': ' + divisors + ' divisors');
          foundIntermediate[i] = true;
        }

        // if number has no more than 200 divisors, no need to test 300, 400, 500.
        break;
      }
    }*/
      
    if (divisors > maxDivisors) {
      isFound = true;
      return currentNumber;
    }
  }

  return currentNumber;
}
